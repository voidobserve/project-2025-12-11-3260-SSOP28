C51 COMPILER V9.60.7.0   UART0                                                             12/12/2025 11:46:24 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE UART0
OBJECT MODULE PLACED IN .\Release\Objects\uart0.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\Hardware\uart0.c LARGE OPTIMIZE(9,SIZE) BROWSE ORDER INTVECTOR(0X0
                    -00C) INCDIR(..\..\Libraries\Include;..\..\User;..\..\User\lib;..\..\Hardware) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(.\Rel
                    -ease\Listings\uart0.lst) OBJECT(.\Release\Objects\uart0.obj)

line level    source

   1          #include "uart0.h"
   2          
   3          #include <string.h> // memset()
   4          
   5          // è®¾ç½®çš„æ³¢ç‰¹ç‡éœ€è¦é€‚é…å•ç‰‡æœºçš„æ—¶é’Ÿï¼Œè¿™é‡Œç›´æ¥ä½¿ç”¨äº†å®˜æ–¹çš„ä»£ç 
   6          #define USER_UART0_BAUD ((SYSCLK - UART0_BAUDRATE) / (UART0_BAUDRATE))
   7          
   8          // ç”¨æ¥å­˜æ”¾æ¥æ”¶çš„æ•°æ®å¸§çš„ç¼“å†²åŒº
   9          volatile u8 uart0_recv_buf[(UART0_RXBUF_LEN) / (FRAME_MAX_LEN)][FRAME_MAX_LEN];
  10          // ç”¨äºè®°å½•æ¥æ”¶ç¼“å†²åŒºçš„å¯¹åº”çš„æ•°æ®å¸§çš„é•¿åº¦
  11          volatile u8 uart0_recv_len[(UART0_RXBUF_LEN) / (FRAME_MAX_LEN)];
  12          // è®°å½•ç¼“å†²åŒºä¸­å¯¹åº”çš„ä½ç½®æ˜¯å¦æœ‰æ•°æ®çš„æ ‡å¿—ä½ï¼ˆæ•°ç»„ï¼‰
  13          // ä¾‹å¦‚ï¼Œç¼“å†²åŒºä¸‹æ ‡0çš„ä½ç½®æœ‰æŒ‡ä»¤ï¼Œæ ‡å¿—ä½æ•°ç»„ä¸‹æ ‡0çš„å…ƒç´ å€¼ä¸º1ï¼Œæ²¡æœ‰æŒ‡ä»¤ï¼Œå
             -…ƒç´ çš„å€¼ä¸º0
  14          volatile u8 recved_flagbuf[(UART0_RXBUF_LEN) / (FRAME_MAX_LEN)];
  15          
  16          volatile u8 flagbuf_valid_instruction[(UART0_RXBUF_LEN) / (FRAME_MAX_LEN)]; // å­˜æ”¾æœ‰åˆæ³•æŒ‡ä»¤çš„æ ‡
             -å¿—ä½æ•°ç»„
  17          
  18          // ä¸²å£ä¸­æ–­æœåŠ¡å‡½æ•°ä¸­ï¼Œæ¥æ”¶ä¸€å¸§çš„æ ‡å¿—ä½ï¼Œ0--å‡†å¤‡æ¥æ”¶ä¸€å¸§çš„ç¬¬ä¸€ä¸ªå­—èŠ‚ï¼Œ1--æ
             -­£åœ¨æ¥æ”¶è¯¥å¸§çš„æ•°æ®
  19          static volatile bit flag_is_recving_data;
  20          static volatile u8 frame_len;    // è®°å½•ä¸²å£ä¸­æ–­æœåŠ¡å‡½æ•°ä¸­ï¼Œå½“å‰è¦æ¥æ”¶çš„æ•°æ®å¸§çš„å­—è
             -Š‚æ•°
  21          static volatile u8 cur_recv_len; // è®°å½•ä¸²å£ä¸­æ–­æœåŠ¡å‡½æ•°ä¸­ï¼Œå½“å‰å·²æ¥æ”¶çš„æ•°æ®å¸§çš„å­—è
             -Š‚æ•°
  22          volatile u8 recv_frame_cnt;      // æ¥æ”¶åˆ°çš„æ•°æ®å¸§çš„ä¸ªæ•°
  23          
  24          static volatile u32 blank_index; // è®°å½•å½“å‰å­˜æ”¾æ•°æ®å¸§çš„ç¼“å†²åŒºçš„ç©ºçš„åœ°æ–¹(ç¼“å†²åŒºä¸‹æ ‡
             -)ï¼Œå‡†å¤‡å­˜æ”¾ä¸€å¸§çš„æ•°æ®
  25          
  26          /*
  27              å¦‚æœä¸²å£æ”¶åˆ°äº†1å­—èŠ‚æ•°æ®ï¼Œå´æœªæ”¶å®Œæ•´ä¸€å¸§æ•°æ®ï¼Œä¼šä½¿èƒ½ä¸²å£æ¥æ”¶è¶…æ—¶
  28              å¦‚æœæ”¶åˆ°äº†å®Œæ•´çš„ä¸€å¸§æ•°æ®ï¼Œä¼šå…³é—­ä¸²å£æ¥æ”¶è¶…æ—¶
  29          */
  30          volatile bit flag_is_uart0_receive_timeout;        // æ ‡å¿—ä½ï¼Œä¸²å£æ˜¯å¦æ¥æ”¶è¶…æ—¶ï¼Œ0--æœªè¶…æ—¶ï
             -¼Œ1--å·²è¶…æ—¶
  31          volatile bit flag_is_uart0_receive_timeout_enable; // æ ‡å¿—ä½ï¼Œæ˜¯å¦ä½¿èƒ½ä¸²å£æ¥æ”¶è¶…æ—¶ï¼Œ0--å¦ï
             -¼Œ1--ä¸²å£æ¥æ”¶äº†æ•°æ®ï¼Œå´æœªæ”¶åˆ°å®Œæ•´ä¸€å¸§æ•°æ®ï¼Œä½¿èƒ½ä¸²å£æ¥æ”¶è¶…æ—¶
  32          volatile u8 uart0_receive_timeout_cnt;            // å­˜æ”¾ä¸²å£æ¥æ”¶è¶…æ—¶è®¡æ•°å€¼
  33          
  34          #if USE_MY_DEBUG
              #if 1 // å°†uart0ç”¨ä½œä¸²å£æ‰“å°
              // é‡å†™putchar()å‡½æ•°
              extern void uart0_sendbyte(u8 senddata); // å‡½æ•°å£°æ˜
              char putchar(char c)
              {
                  uart0_sendbyte(c);
                  return c;
              }
              #endif // å°†uart0ç”¨ä½œä¸²å£æ‰“å°
              #endif // #if USE_MY_DEBUG
  45          
C51 COMPILER V9.60.7.0   UART0                                                             12/12/2025 11:46:24 PAGE 2   

  46          static void uart0_receive_timeout_enable(void)
  47          {
  48   1          uart0_receive_timeout_cnt = 0;            // è¶…æ—¶è®¡æ•°å€¼æ¸…é›¶
  49   1          flag_is_uart0_receive_timeout = 0;        // è¡¨ç¤ºæœªæ¥æ”¶è¶…æ—¶
  50   1          flag_is_uart0_receive_timeout_enable = 1; // ä½¿èƒ½æ¥æ”¶è¶…æ—¶
  51   1      }
  52          
  53          static void uart0_receive_timeout_disable(void)
  54          {
  55   1          flag_is_uart0_receive_timeout_enable = 0; // ä¸ä½¿èƒ½æ¥æ”¶è¶…æ—¶
  56   1          uart0_receive_timeout_cnt = 0;            // è¶…æ—¶è®¡æ•°å€¼æ¸…é›¶
  57   1          flag_is_uart0_receive_timeout = 0;        // è¡¨ç¤ºæœªæ¥æ”¶è¶…æ—¶
  58   1      }
  59          
  60          // uart0åˆå§‹åŒ–
  61          // æ³¢ç‰¹ç‡ç”±å® UART0_BAUDRATE æ¥å†³å®š
  62          void uart0_config(void)
  63          {
  64   1      // P03 ä¸ºå•ç‰‡æœºTXï¼ŒP00 ä¸ºå•ç‰‡æœºRX
  65   1      #if 1
  66   1          P0_MD0 &= ~(GPIO_P03_MODE_SEL(0x03)); // æ¸…ç©ºå¯„å­˜å™¨é…ç½®
  67   1          P0_MD0 &= ~(GPIO_P00_MODE_SEL(0x03)); // æ¸…ç©ºå¯„å­˜å™¨é…ç½®
  68   1          P0_MD0 |= GPIO_P03_MODE_SEL(0x01);    // è¾“å‡ºæ¨¡å¼
  69   1          FOUT_S03 |= GPIO_FOUT_UART0_TX;       // é…ç½®P03ä¸ºUART0_TX
  70   1          FIN_S7 |= GPIO_FIN_SEL_P00;           // é…ç½®P00ä¸ºUART0_RX
  71   1      #endif
  72   1      
  73   1          // // æ—§ç‰ˆç”µè·¯æ¿ä¸Šï¼ŒP11ä¸ºå‘é€å¼•è„šï¼ŒP12ä¸ºæ¥æ”¶å¼•è„š
  74   1          // P1_MD0 &= (~GPIO_P11_MODE_SEL(0x3) | ~GPIO_P12_MODE_SEL(0x3));
  75   1          // P1_MD0 |= GPIO_P11_MODE_SEL(0x1); // è¾“å‡ºæ¨¡å¼
  76   1          // FOUT_S11 |= GPIO_FOUT_UART0_TX;   // é…ç½®P11ä¸ºUART0_TX
  77   1          // FIN_S7 |= GPIO_FIN_SEL_P12;       // é…ç½®P12ä¸ºUART0_RX
  78   1      
  79   1      #if 0
                  // æµ‹è¯•æ—¶ï¼Œä½¿ç”¨å¼€å‘æ¿ä¸Šé¢çš„P25æ¥æ‰“å°è¾“å‡º
                  P2_MD1 &= ~(GPIO_P25_MODE_SEL(0x03)); // æ¸…ç©ºå¯„å­˜å™¨é…ç½®
                  P2_MD1 |= GPIO_P25_MODE_SEL(0x01);    // è¾“å‡ºæ¨¡å¼
                  FOUT_S25 |= GPIO_FOUT_UART0_TX;       // é…ç½®ä¸ºUART0_TX
                  // æµ‹è¯•æ—¶ï¼Œä½¿ç”¨å¼€å‘æ¿ä¸Šé¢çš„P22æ¥ä½œä¸ºæ¥æ”¶ï¼š
                  P2_MD0 &= ~(GPIO_P22_MODE_SEL(0x03)); // æ¸…ç©ºå¯„å­˜å™¨é…ç½®ï¼Œè¾“å…¥æ¨¡å¼
                  FIN_S7 |= GPIO_FIN_SEL_P22;           // é…ç½®ä¸ºUART0_RX
              #endif
  88   1      
  89   1          __EnableIRQ(UART0_IRQn); // æ‰“å¼€UARTæ¨¡å—ä¸­æ–­
  90   1          IE_EA = 1;               // æ‰“å¼€æ€»ä¸­æ–­
  91   1      
  92   1          UART0_BAUD1 = (USER_UART0_BAUD >> 8) & 0xFF; // é…ç½®æ³¢ç‰¹ç‡é«˜å…«ä½
  93   1          UART0_BAUD0 = USER_UART0_BAUD & 0xFF;        // é…ç½®æ³¢ç‰¹ç‡ä½å…«ä½
  94   1          UART0_CON0 = UART_STOP_BIT(0x0) |
  95   1                       UART_RX_IRQ_EN(0x1) |
  96   1                       UART_EN(0x1); // 8bitæ•°æ®ï¼Œ1bitåœæ­¢ä½ï¼Œä½¿èƒ½RXä¸­æ–­
  97   1      }
  98          
  99          // UART0ä¸­æ–­æœåŠ¡å‡½æ•°ï¼ˆæ¥æ”¶ä¸­æ–­ï¼‰
 100          void UART0_IRQHandler(void) interrupt UART0_IRQn
 101          {
 102   1          volatile u8 uart0_tmp_val = 0;
 103   1      
 104   1          // è¿›å…¥ä¸­æ–­è®¾ç½®IPï¼Œä¸å¯åˆ é™¤
 105   1          __IRQnIPnPush(UART0_IRQn);
 106   1          // P20 = 1; // æµ‹è¯•ä¸­æ–­æŒç»­æ—¶é—´
 107   1      
C51 COMPILER V9.60.7.0   UART0                                                             12/12/2025 11:46:24 PAGE 3   

 108   1          // ---------------- ç”¨æˆ·å‡½æ•°å¤„ç† -------------------
 109   1          // RXæ¥æ”¶å®Œæˆä¸­æ–­
 110   1          if (UART0_STA & UART_RX_DONE(0x1))
 111   1          {
 112   2              // test_bit = 1;
 113   2              uart0_tmp_val = UART0_DATA; // ä¸´æ—¶å­˜æ”¾æ¥æ”¶åˆ°çš„æ•°æ®
 114   2      
 115   2              if ((0 == flag_is_recving_data && uart0_tmp_val != 0xA5) ||
 116   2                  (recv_frame_cnt >= ((UART0_RXBUF_LEN) / (FRAME_MAX_LEN))))
 117   2              {
 118   3                  // 1. å¦‚æœæ˜¯æ–°çš„ä¸€å¸§æ•°æ®ï¼Œå´ä¸æ˜¯ä»¥0xA5å¼€å¤´ï¼Œè¯´æ˜è¿™ä¸€å¸§æ•°æ®æ— æ•ˆ
 119   3                  // 2. å¦‚æœç¼“å†²åŒºå·²æ»¡ï¼Œå­˜ä¸ä¸‹æ›´å¤šçš„æ•°æ®å¸§
 120   3                  // ç›´æ¥é€€å‡ºä¸­æ–­ï¼Œä¸å¤„ç†æ•°æ®
 121   3                  // tmr0_disable();
 122   3                  // tmr0_cnt = 0;
 123   3      
 124   3                  uart0_receive_timeout_disable(); // ä¸ä½¿èƒ½ä¸²å£æ¥æ”¶è¶…æ—¶æ£€æµ‹åŠŸèƒ½
 125   3      
 126   3                  __IRQnIPnPop(UART0_IRQn);
 127   3                  return;
 128   3              }
 129   2              // if ((0 == flag_is_recving_data && UART0_DATA == 0xA5) ||
 130   2              //     (1 == flag_is_recving_data && UART0_DATA == 0xA5))
 131   2              else if (uart0_tmp_val == FORMAT_HEAD)
 132   2              {
 133   3                  // 1. å¦‚æœæ˜¯æ–°çš„ä¸€å¸§æ•°æ®ï¼ˆä»¥æ ¼å¼å¤´0xA5å¼€å§‹ï¼‰ï¼Œæ‰“å¼€å®šæ—¶å™¨ï¼Œä¸ºè¶…æ—¶åˆ¤
             -æ–­åšå‡†å¤‡
 134   3                  // 2. å¦‚æœæ­£åœ¨æ¥æ”¶ä¸€å¸§æ•°æ®ï¼Œå´åˆæ”¶åˆ°äº†ä¸€æ¬¡æ ¼å¼å¤´ï¼Œèˆå¼ƒä¹‹å‰æ”¶åˆ°çš„æ
             -•°æ®ï¼Œé‡æ–°æ¥æ”¶è¿™ä¸€å¸§
 135   3                  flag_is_recving_data = 1;
 136   3                  cur_recv_len = 0;
 137   3                  frame_len = 0;
 138   3      
 139   3                  // tmr0_disable();
 140   3                  // tmr0_cnt = 0;
 141   3                  // tmr0_enable();
 142   3                  uart0_receive_timeout_enable();
 143   3              }
 144   2      
 145   2              if (1 == cur_recv_len)
 146   2              {
 147   3                  // å¦‚æœæ¥æ”¶åˆ°ä¸€å¸§çš„ç¬¬äºŒä¸ªå­—èŠ‚çš„æ•°æ®ï¼Œè®°å½•ä¸‹è¦æ¥æ”¶çš„æ•°æ®é•¿åº¦
 148   3                  frame_len = uart0_tmp_val;
 149   3                  // test_val = frame_len;
 150   3                  // printf("frame_len %d\n", (int32)frame_len);
 151   3              }
 152   2      
 153   2              // ç¨‹åºè¿è¡Œåˆ°è¿™é‡Œï¼Œè¯´æ˜æ­£åœ¨æ¥æ”¶ä¸€ä¸ªæ•°æ®å¸§
 154   2              if (0 == recved_flagbuf[blank_index])
 155   2              {
 156   3                  // å¦‚æœç¼“å†²åŒºä¸­æœ‰å‰©ä½™ä½ç½®æ¥å­˜æ”¾ä¸€ä¸ªå¸§ï¼Œæ‰æ”¾å…¥æ•°æ®
 157   3                  uart0_recv_buf[blank_index][cur_recv_len++] = uart0_tmp_val;
 158   3                  // uart0_recv_buf[0][cur_recv_len++] = UART0_DATA; // æµ‹è¯•ç”¨
 159   3      
 160   3                  // tmr0_cnt = 0; // æ¯æ¥æ”¶åˆ°ä¸€ä¸ªå­—èŠ‚æ•°æ®ï¼Œæ¸…ç©ºè¶…æ—¶çš„è®¡æ—¶
 161   3                  uart0_receive_timeout_cnt = 0; // æ¯æ¥æ”¶åˆ°ä¸€ä¸ªå­—èŠ‚æ•°æ®ï¼Œæ¸…ç©ºè¶…æ—¶çš„è®¡æ—¶
 162   3      
 163   3                  if ((frame_len != 0) &&
 164   3                      (cur_recv_len) == frame_len)
 165   3                  {
 166   4                      // å¦‚æœæ¥æ”¶å®Œäº†ä¸€å¸§æ•°æ®
 167   4                      uart0_recv_len[blank_index] = frame_len; // æ›´æ–°å½“å‰æ•°æ®å¸§çš„é•¿åº¦
C51 COMPILER V9.60.7.0   UART0                                                             12/12/2025 11:46:24 PAGE 4   

 168   4                      // printf("frame_len %d\n", (int32)frame_len);
 169   4                      flag_is_recving_data = 0; // æ ‡å¿—ä½æ¸…é›¶ï¼Œå‡†å¤‡æ¥æ”¶ä¸‹ä¸€å¸§æ•°æ®
 170   4                      cur_recv_len = 0;
 171   4                      frame_len = 0;
 172   4      
 173   4                      recved_flagbuf[blank_index] = 1; // å¯¹åº”çš„æ¥æ”¶å®Œæˆæ ‡å¿—ä½ç½®ä¸€
 174   4                      recv_frame_cnt++;                // æ¥æ”¶åˆ°å®Œæ•´çš„ä¸€å¸§ï¼Œè®¡æ•°å€¼åŠ ä¸€
 175   4                      // test_bit = 1; // æµ‹è¯•ç”¨
 176   4                      blank_index++;
 177   4                      if (blank_index >= ((UART0_RXBUF_LEN) / (FRAME_MAX_LEN)))
 178   4                      {
 179   5                          blank_index = 0;
 180   5                      }
 181   4      
 182   4                      // if (recv_frame_cnt < ((UART0_RXBUF_LEN) / (FRAME_MAX_LEN)))
 183   4                      // {
 184   4                      //     // å¦‚æœæ•°ç»„ä¸­æœ‰ç©ºä½ï¼ˆæ¥æ”¶çš„æ•°æ®å¸§ä¸ªæ•° < ç¼“å†²åŒºæ€»å…±èƒ½æ¥æ”¶çš
             -„æ•°æ®å¸§ä¸ªæ•°ï¼‰
 185   4      
 186   4                      //     // åç§»åˆ°æ•°ç»„ä¸­ç©ºçš„åœ°æ–¹ï¼Œå‡†å¤‡å¡«å…¥ä¸‹ä¸€ä¸ªæ•°æ®å¸§
 187   4                      //     while (1)
 188   4                      //     {
 189   4                      //         blank_index++;
 190   4      
 191   4                      //         if (blank_index >= ((UART0_RXBUF_LEN) / (FRAME_MAX_LEN)))
 192   4                      //         {
 193   4                      //             // å¦‚æœä¸‹æ ‡è¶…å‡ºäº†ç¼“å†²åŒºèƒ½å®¹çº³çš„æŒ‡ä»¤ä¸ªæ•°
 194   4                      //             blank_index = 0;
 195   4                      //         }
 196   4      
 197   4                      //         if (0 == recved_flagbuf[blank_index])
 198   4                      //         {
 199   4                      //             // å¦‚æœæ˜¯ç©ºçš„ä¸€å¤„ç¼“å†²åŒºï¼Œé€€å‡ºï¼Œå‡†å¤‡ç»™ä¸‹ä¸€æ¬¡æ¥æ”¶æ•°æ®
             -å¸§
 200   4                      //             break;
 201   4                      //         }
 202   4                      //     }
 203   4                      // }
 204   4      
 205   4                      {
 206   5                          // tmr0_disable();
 207   5                          // tmr0_cnt = 0;
 208   5                          
 209   5                          uart0_receive_timeout_disable(); // ä¸ä½¿èƒ½æ¥æ”¶è¶…æ—¶æ£€æµ‹åŠŸèƒ½
 210   5                          __IRQnIPnPop(UART0_IRQn);
 211   5                          return;
 212   5                      }
 213   4                  } // if ((cur_recv_len) == frame_len)
 214   3              } // if (0 == recved_flagbuf[blank_index])
 215   2              // else // å¦‚æœå½“å‰ç¼“å†²åŒºä¸­æ²¡æœ‰å‰©ä½™ä½ç½®æ¥å­˜æ”¾ä¸€ä¸ªå¸§ï¼Œ
 216   2              // {
 217   2              // }
 218   2      
 219   2          } // if (UART0_STA & UART_RX_DONE(0x1))
 220   1      
 221   1          // P20 = 0; // æµ‹è¯•ä¸­æ–­æŒç»­æ—¶é—´
 222   1          // é€€å‡ºä¸­æ–­è®¾ç½®IPï¼Œä¸å¯åˆ é™¤
 223   1          __IRQnIPnPop(UART0_IRQn);
 224   1      }
 225          
 226          // UART0å‘é€ä¸€ä¸ªå­—èŠ‚æ•°æ®çš„å‡½æ•°
 227          void uart0_sendbyte(u8 senddata)
C51 COMPILER V9.60.7.0   UART0                                                             12/12/2025 11:46:24 PAGE 5   

 228          {
 229   1          while (!(UART0_STA & UART_TX_DONE(0x01)))
 230   1              ;
 231   1          UART0_DATA = senddata;
 232   1          while (!(UART0_STA & UART_TX_DONE(0x01))) // ç­‰å¾…è¿™æ¬¡å‘é€å®Œæˆ
 233   1              ;
 234   1      }
 235          
 236          #if 0  // void uart0_send_buff(u8 *buf, u8 len)
              // é€šè¿‡uart0å‘é€è‹¥å¹²æ•°æ®
              void uart0_send_buff(u8 *buf, u8 len)
              {
                  u8 i = 0;
                  for (; i < len; i++)
                  {
                      uart0_sendbyte(buf[i]);
                  }
              }
              #endif // void uart0_send_buff(u8 *buf, u8 len)
 247          
 248          // å¯¹UART0æ¥æ”¶ç¼“å†²åŒºçš„æ•°æ®è¿›è¡ŒéªŒè¯ï¼ˆè¶…æ—¶éªŒè¯ã€é•¿åº¦éªŒè¯ã€æ ¡éªŒå’Œè®¡ç®—ï¼‰
 249          extern void __uart_buff_check(void);
 250          void uart0_scan_handle(void)
 251          {
 252   1          u8 i = 0;                                  // å¾ªç¯è®¡æ•°å€¼ï¼ˆæ³¨æ„å¾ªç¯æ¬¡æ•°è¦å¤§äºç­‰äºæ•°ç»
             -„èƒ½å­˜æ”¾çš„æŒ‡ä»¤æ•°ç›®ï¼‰
 253   1          volatile u8 checksum = 0;                  // å­˜æ”¾ä¸´æ—¶çš„æ ¡éªŒå’Œ
 254   1          volatile bit __flag_is_crc_or_len_err = 0; // æ ‡å¿—ä½ï¼Œæ ¡éªŒå’Œ / æ•°æ®é•¿åº¦ æ˜¯å¦é”™è¯¯,0--æœª
             -å‡ºé”™ï¼Œ1--å‡ºé”™
 255   1      
 256   1      #if 1 // æ¥æ”¶è¶…æ—¶å¤„ç†
 257   1      
 258   1          //     if (tmr0_cnt > 10) // ä¸€å¸§å†…ï¼Œè¶…è¿‡10msæ²¡æœ‰æ”¶åˆ°æ•°æ®
 259   1          //     {
 260   1          //         // å¦‚æœè¶…æ—¶
 261   1          //         // uart0_sendstr("Time out!\n");
 262   1      
 263   1          //         tmr0_disable(); // å…³é—­å®šæ—¶å™¨
 264   1          //         tmr0_cnt = 0;   // æ¸…ç©ºå®šæ—¶å™¨è®¡æ•°å€¼
 265   1      
 266   1          //         // å½“å‰çš„æ•°æ®å¸§ä½œåºŸ
 267   1          //         cur_recv_len = 0;         // å½“å‰æ¥æ”¶åˆ°çš„å¸§çš„é•¿åº¦æ¸…é›¶
 268   1          //         frame_len = 0;            // è¦æ¥æ”¶çš„å¸§çš„é•¿åº¦ï¼Œæ¸…é›¶
 269   1          //         flag_is_recving_data = 0; // é‡æ–°å¼€å§‹æ¥æ”¶æ•°æ®
 270   1      
 271   1          //         // if (0 == recved_flagbuf[blank_index])
 272   1          //         // {
 273   1          //         //     memset(uart0_recv_buf[blank_index], 0, FRAME_MAX_LEN); // æ¸…ç©ºè¶…æ—¶çš„æŒ‡ä»¤å¯¹åº
             -”çš„æ¥æ”¶ç¼“å†²åŒº
 274   1          //         // }
 275   1      
 276   1          //         // printf("recv time out! \n");
 277   1      
 278   1          // #if 0 // æ‰“å°ä¸²å£ç¼“å†²åŒºçš„æ•°æ®
 279   1      
 280   1          //         {
 281   1          //             u8 i = 0;
 282   1          //             u8 j = 0;
 283   1          //             for (i = 0; i < (UART0_RXBUF_LEN) / (FRAME_MAX_LEN); i++)
 284   1          //             {
 285   1          //                 printf("buff_index %bu ", i);
 286   1          //                 for (j = 0; j < FRAME_MAX_LEN; j++)
C51 COMPILER V9.60.7.0   UART0                                                             12/12/2025 11:46:24 PAGE 6   

 287   1          //                 {
 288   1          //                     printf("%bx ", uart0_recv_buf[i][j]);
 289   1          //                 }
 290   1          //                 printf("\n");
 291   1          //             }
 292   1          //         }
 293   1      
 294   1          // #endif // æ‰“å°ä¸²å£ç¼“å†²åŒºçš„æ•°æ®
 295   1      
 296   1          //         return;
 297   1          //     }
 298   1      
 299   1          if (uart0_receive_timeout_cnt > 10) // ä¸€å¸§å†…ï¼Œè¶…è¿‡10msæ²¡æœ‰æ”¶åˆ°æ•°æ®
 300   1          {
 301   2              // å¦‚æœè¶…æ—¶
 302   2              //    printf("timeout\n");
 303   2      
 304   2              uart0_receive_timeout_disable(); // å…³é—­ä¸²å£æ¥æ”¶è¶…æ—¶æ£€æµ‹åŠŸèƒ½
 305   2      
 306   2              // å½“å‰çš„æ•°æ®å¸§ä½œåºŸ
 307   2              cur_recv_len = 0;         // å½“å‰æ¥æ”¶åˆ°çš„å¸§çš„é•¿åº¦æ¸…é›¶
 308   2              frame_len = 0;            // è¦æ¥æ”¶çš„å¸§çš„é•¿åº¦ï¼Œæ¸…é›¶
 309   2              flag_is_recving_data = 0; // é‡æ–°å¼€å§‹æ¥æ”¶æ•°æ®
 310   2      
 311   2              return;
 312   2          }
 313   1      #endif // æ¥æ”¶è¶…æ—¶å¤„ç†
 314   1      
 315   1          // å¯¹æ”¶åˆ°çš„æ•°æ®å¸§è¿›è¡ŒéªŒè¯
 316   1          for (i = 0; i < ((UART0_RXBUF_LEN) / (FRAME_MAX_LEN)); i++)
 317   1          {
 318   2              if (recved_flagbuf[i])
 319   2              {
 320   3                  // å¦‚æœå¯¹åº”çš„ä½ç½®æœ‰å®Œæ•´çš„æ•°æ®å¸§
 321   3                  // __uart_buff_check(); // æµ‹è¯•ç”¨
 322   3      
 323   3                  if (uart0_recv_len[i] != uart0_recv_buf[i][1])
 324   3                  {
 325   4                      // å¦‚æœæ•°æ®å¸§çš„é•¿åº¦ä¸æ­£ç¡®
 326   4      
 327   4                      // printf("format len invalid!\n");
 328   4                      // printf("%d  %d \n", (u32)uart0_recv_len[i], (u32)uart0_recv_buf[i][1]);
 329   4                      // __uart_buff_check(); // æ‰“å°ä¸²å£æ¥æ”¶ç¼“å†²åŒºä¸­çš„æ•°æ®
 330   4      
 331   4                      recved_flagbuf[i] = 0;
 332   4                      recv_frame_cnt--;
 333   4                      memset(uart0_recv_buf[i], 0, FRAME_MAX_LEN);
 334   4      
 335   4                      return;
 336   4                  }
 337   3      
 338   3                  {                          // è®¡ç®—æ ¡éªŒå’Œ
 339   4                      u8 __loop_crc_cnt = 0; // ç”¨äºè®¡ç®—æ ¡éªŒå’Œçš„å¾ªç¯è®¡æ•°å€¼
 340   4                      checksum = 0;
 341   4                      for (__loop_crc_cnt = 0; __loop_crc_cnt < (uart0_recv_len[i] - 1); __loop_crc_cnt++)
 342   4                      {
 343   5                          checksum += uart0_recv_buf[i][__loop_crc_cnt];
 344   5                      }
 345   4      
 346   4                      // checksum &= 0x0F; // å–ä½4ä½ä½œä¸ºæ ¡éªŒ
 347   4                      checksum &= 0xFF; // å–8ä½ä½œä¸ºæ ¡éªŒ
 348   4                      if (checksum != (uart0_recv_buf[i][uart0_recv_len[i] - 1]))
C51 COMPILER V9.60.7.0   UART0                                                             12/12/2025 11:46:24 PAGE 7   

 349   4                      {
 350   5                          // å¦‚æœè®¡ç®—çš„æ ¡éªŒå’Œä¸æ”¶åˆ°çš„æ ¡éªŒå’Œä¸ä¸€è‡´
 351   5                          __flag_is_crc_or_len_err = 1;
 352   5                      }
 353   4                  } // è®¡ç®—æ ¡éªŒå’Œ
 354   3      
 355   3                  if (__flag_is_crc_or_len_err)
 356   3                  {
 357   4      
 358   4      #if 0 // æ‰“å°ä¸²å£ç¼“å†²åŒºçš„æ•°æ®
                              printf("recv crc or len err! \n");
                              {
                                  u8 i = 0;
                                  u8 j = 0;
                                  for (i = 0; i < (UART0_RXBUF_LEN) / (FRAME_MAX_LEN); i++)
                                  {
                                      printf("buff_index %bu ", i);
                                      for (j = 0; j < FRAME_MAX_LEN; j++)
                                      {
                                          printf("%bx ", uart0_recv_buf[i][j]);
                                      }
                                      printf("\n");
                                  }
                              }
              
              #endif // æ‰“å°ä¸²å£ç¼“å†²åŒºçš„æ•°æ®
 375   4      
 376   4                      // flag_is_recving_data = 0;
 377   4                      __flag_is_crc_or_len_err = 0; //
 378   4                      recved_flagbuf[i] = 0;
 379   4                      recv_frame_cnt--;
 380   4                      memset(uart0_recv_buf[i], 0, FRAME_MAX_LEN); // æ¸…ç©ºæ ¡éªŒå’Œé”™è¯¯çš„æŒ‡ä»¤å¯¹åº”çš„ç¼“
             -å†²åŒº
 381   4                  }
 382   3      
 383   3                  // å¦‚æœè¿è¡Œåˆ°è¿™é‡Œï¼Œæ•°æ®éƒ½æ­£å¸¸
 384   3                  flagbuf_valid_instruction[i] = 1; // å¯¹åº”çš„æ ‡å¿—ä½ç½®ä¸€ï¼Œè¡¨ç¤ºæ”¶åˆ°äº†åˆæ³•çš„æŒ‡ä»¤
 385   3              } // if (recved_flagbuf[i])
 386   2          } // for (i = 0; i < ((UART0_RXBUF_LEN) / (FRAME_MAX_LEN)); i++)
 387   1      }
 388          
 389          #if 0
              // æ¸…é™¤ä¸²å£æ¥æ”¶ç¼“å†²åŒºä¸­ï¼Œå•ä¸ªå·²ç»å¤„ç†å¥½çš„æŒ‡ä»¤
              void uart_clear_single_instruction(u8 index)
              {
                  flagbuf_valid_instruction[index] = 0;            // æ¸…ç©ºç¼“å†²åŒºå¯¹åº”çš„å…ƒç´ ï¼Œè¡¨ç¤ºè¯¥ä¸‹æ ‡çš
             -„æŒ‡ä»¤å·²ç»å¤„ç†
                  uart0_recv_len[index] = 0;                       // æ¸…é™¤ç¼“å†²åŒºä¸­æŒ‡ä»¤å¯¹åº”çš„é•¿åº¦
                  recved_flagbuf[index] = 0;                       // æ¸…é™¤æ¥æ”¶åˆ°æŒ‡ä»¤çš„æ ‡å¿—ä½
                  memset(uart0_recv_buf[index], 0, FRAME_MAX_LEN); // æ¸…ç©ºç¼“å†²åŒºå¯¹åº”çš„æŒ‡ä»¤
              }
              #endif
 399          
 400          #ifdef USE_MY_DEBUG
 401          #if USE_MY_DEBUG
              // æµ‹è¯•ç”¨çš„ç¨‹åºï¼š
              // æ˜¾ç¤ºä¸²å£ç¼“å†²åŒºä¸­çš„æ•°æ®ï¼š
              // void __uart_buff_check(void)
              // {
              //     u8 i = 0;
              
              //     u8 k = 0;
C51 COMPILER V9.60.7.0   UART0                                                             12/12/2025 11:46:24 PAGE 8   

              //     // if (test_bit)
              //     // {
              //     //     test_bit = 0;
              //     for (i = 0; i < (UART0_RXBUF_LEN) / (FRAME_MAX_LEN); i++)
              //     {
              //         uart0_sendbyte(i + '0');
              //         uart0_sendbyte('\n');
              //         for (k = 0; k < FRAME_MAX_LEN; k++)
              //         {
              //             printf("%2x ", (u16)uart0_recv_buf[i][k]);
              //         }
              
              //         printf("\n==========================\n");
              //     }
              //     // }
              // }
              #endif
 426          #endif // void __uart_buff_check(void)
 427          
 428          #if 0
                          switch (uart0_recv_len[i])
                          {
                          case 4:
              
                              // å¦‚æœæ˜¯å››ä¸ªå­—èŠ‚çš„æ•°æ®
                              checksum = (uart0_recv_buf[i][0] + uart0_recv_buf[i][1] + uart0_recv_buf[i][2]) & 0x0F;
              
                              if (checksum != uart0_recv_buf[i][3])
                              {
                                  // å¦‚æœè®¡ç®—å¾—å‡ºçš„æ ¡éªŒå’Œä¸æ•°æ®å¸§ä¸­çš„æ ¡éªŒå’Œä¸ä¸€è‡´
                                  // è¯´æ˜ä¼ è¾“çš„æ•°æ®æœ‰è¯¯
                                  // uart0_sendstr("checknum err_4Bytes\n");
                                  // recved_flagbuf[i] = 0;
                                  // recv_frame_cnt--;
                                  // memset(uart0_recv_buf[i], 0, FRAME_MAX_LEN);
                                  __flag_is_crc_or_len_err = 1;
                              }
              
                              break;
              
                          case 5:
              
                              // å¦‚æœæ˜¯äº”ä¸ªå­—èŠ‚çš„æ•°æ®
                              checksum = (uart0_recv_buf[i][0] + uart0_recv_buf[i][1] + uart0_recv_buf[i][2] + uart0_rec
             -v_buf[i][3]) & 0x0F;
                              if (checksum != uart0_recv_buf[i][4])
                              {
                                  // å¦‚æœè®¡ç®—å¾—å‡ºçš„æ ¡éªŒå’Œä¸æ•°æ®å¸§ä¸­çš„æ ¡éªŒå’Œä¸ä¸€è‡´
                                  // è¯´æ˜ä¼ è¾“çš„æ•°æ®æœ‰è¯¯
                                  // uart0_sendstr("checknum err_5Bytes\n");
                                  // recved_flagbuf[i] = 0;
                                  // recv_frame_cnt--;
                                  // memset(uart0_recv_buf[i], 0, FRAME_MAX_LEN);
                                  __flag_is_crc_or_len_err = 1;
                              }
              
                              break;
                          case 6:
              
                              // å¦‚æœæ˜¯å…­ä¸ªå­—èŠ‚çš„æ•°æ®
                              checksum = (uart0_recv_buf[i][0] + uart0_recv_buf[i][1] + uart0_recv_buf[i][2] + uart0_rec
             -v_buf[i][3] + uart0_recv_buf[i][4]) & 0x0F;
C51 COMPILER V9.60.7.0   UART0                                                             12/12/2025 11:46:24 PAGE 9   

              
                              if (checksum != uart0_recv_buf[i][5])
                              {
                                  // å¦‚æœè®¡ç®—å¾—å‡ºçš„æ ¡éªŒå’Œä¸æ•°æ®å¸§ä¸­çš„æ ¡éªŒå’Œä¸ä¸€è‡´
                                  // è¯´æ˜ä¼ è¾“çš„æ•°æ®æœ‰è¯¯
                                  // uart0_sendstr("checknum err_6Bytes\n");
                                  // recved_flagbuf[i] = 0;
                                  // recv_frame_cnt--;
                                  // memset(uart0_recv_buf[i], 0, FRAME_MAX_LEN);
                                  __flag_is_crc_or_len_err = 1;
                              }
              
                              break;
                          case 7: // å¦‚æœæ˜¯7ä¸ªå­—èŠ‚çš„æ•°æ®
                              checksum = (uart0_recv_buf[i][0] + uart0_recv_buf[i][1] + uart0_recv_buf[i][2] + uart0_rec
             -v_buf[i][3] + uart0_recv_buf[i][4] + uart0_recv_buf[i][5]) & 0x0F;
                              if (checksum != uart0_recv_buf[i][6])
                              {
                                  // å¦‚æœè®¡ç®—å¾—å‡ºçš„æ ¡éªŒå’Œä¸æ•°æ®å¸§ä¸­çš„æ ¡éªŒå’Œä¸ä¸€è‡´
                                  // è¯´æ˜ä¼ è¾“çš„æ•°æ®æœ‰è¯¯
                                  // recved_flagbuf[i] = 0;
                                  // recv_frame_cnt--;
              
                                  __flag_is_crc_or_len_err = 1;
                              }
                              break;
                          case 8: // å¦‚æœæ˜¯8ä¸ªå­—èŠ‚çš„æ•°æ®
                              checksum = (uart0_recv_buf[i][0] + uart0_recv_buf[i][1] + uart0_recv_buf[i][2] + uart0_rec
             -v_buf[i][3] + uart0_recv_buf[i][4] + uart0_recv_buf[i][5] + uart0_recv_buf[i][6]) & 0x0F;
                              if (checksum != uart0_recv_buf[i][7])
                              {
                                  // å¦‚æœè®¡ç®—å¾—å‡ºçš„æ ¡éªŒå’Œä¸æ•°æ®å¸§ä¸­çš„æ ¡éªŒå’Œä¸ä¸€è‡´
                                  // è¯´æ˜ä¼ è¾“çš„æ•°æ®æœ‰è¯¯
                                  // recved_flagbuf[i] = 0;
                                  // recv_frame_cnt--;
                                  __flag_is_crc_or_len_err = 1;
                              }
                              break;
              
                          default:
                              // å¦‚æœä¸æ˜¯å››ã€äº”ã€å…­ã€ä¸ƒã€å…«ä¸ªå­—èŠ‚çš„æ•°æ®ï¼Œè¯´æ˜æ¥æ”¶æœ‰è¯¯ï¼Œç›´æ¥
             -æŠ›å¼ƒè¿™ä¸€å¸§æ•°æ®
              #if USE_MY_DEBUG
                              // printf("recv cnt err\n");
                              __flag_is_crc_or_len_err = 1;
              #endif
                              // recved_flagbuf[i] = 0;
                              // recv_frame_cnt--;
                              // memset(uart0_recv_buf[i], 0, FRAME_MAX_LEN);
              
                              break;
                          } // switch (uart0_recv_len[i])
              #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    721    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     62       4
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
C51 COMPILER V9.60.7.0   UART0                                                             12/12/2025 11:46:24 PAGE 10  

   BIT SIZE         =      3       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
