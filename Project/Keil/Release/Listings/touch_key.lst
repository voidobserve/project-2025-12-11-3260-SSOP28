C51 COMPILER V9.60.7.0   TOUCH_KEY                                                         12/12/2025 11:46:26 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE TOUCH_KEY
OBJECT MODULE PLACED IN .\Release\Objects\touch_key.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\User\touch_key.c LARGE OPTIMIZE(9,SIZE) BROWSE ORDER INTVECTOR(0X0
                    -00C) INCDIR(..\..\Libraries\Include;..\..\User;..\..\User\lib;..\..\Hardware) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(.\Rel
                    -ease\Listings\touch_key.lst) OBJECT(.\Release\Objects\touch_key.obj)

line level    source

   1          #include "touch_key.h"
   2          
   3          #if TOUCH_KEY_ENABLE
              /*
                  æ ‡å¿—ä½ï¼Œè§¦æ‘¸æŒ‰é”®çš„æ‰«æå‘¨æœŸæ˜¯å¦åˆ°æ¥
                  ç”±å®šæ—¶å™¨ä¸­æ–­ç½®ä½ï¼Œæ‰«æå‡½æ•°ä¸­åˆ¤æ–­è¯¥æ ‡å¿—ä½çš„çŠ¶æ€ï¼Œå†å†³å®šæ˜¯å¦è¦è¿›è¡ŒæŒ‰é”®
             -æ‰«æ
              */
              // volatile bit flag_is_touch_key_scan_circle_arrived;
              
              // å®šä¹‰è§¦æ‘¸æŒ‰é”®çš„æŒ‰é”®äº‹ä»¶
              enum TOUCH_KEY_EVENT
              {
                  TOUCH_KEY_EVENT_NONE = 0,
                  TOUCH_KEY_EVENT_ID_1_CLICK,
                  TOUCH_KEY_EVENT_ID_1_DOUBLE,
                  TOUCH_KEY_EVENT_ID_1_LONG,
                  TOUCH_KEY_EVENT_ID_1_HOLD,
                  TOUCH_KEY_EVENT_ID_1_LOOSE,
              
                  TOUCH_KEY_EVENT_ID_2_CLICK,
                  TOUCH_KEY_EVENT_ID_2_DOUBLE,
                  TOUCH_KEY_EVENT_ID_2_LONG,
                  TOUCH_KEY_EVENT_ID_2_HOLD,
                  TOUCH_KEY_EVENT_ID_2_LOOSE,
              };
              
              #define TOUCH_KEY_EFFECT_EVENT_NUMS (5) // å•ä¸ªè§¦æ‘¸æŒ‰é”®çš„æœ‰æ•ˆæŒ‰é”®äº‹ä»¶ä¸ªæ•°
              // å°†æŒ‰é”®idå’ŒæŒ‰é”®äº‹ä»¶ç»‘å®šèµ·æ¥ï¼Œåœ¨ xx å‡½æ•°ä¸­ï¼Œé€šè¿‡æŸ¥è¡¨çš„æ–¹å¼å¾—åˆ°æŒ‰é”®äº‹ä»¶
              static const u8 touch_key_event_table[][TOUCH_KEY_EFFECT_EVENT_NUMS + 1] = {
                  // [0]--æŒ‰é”®å¯¹åº”çš„idå·ï¼Œç”¨äºæŸ¥è¡¨ï¼Œ[1]ã€[2]ã€[3]...--ç”¨äºä¸ key_driver.h ä¸­å®šä¹‰çš„æ
             -Œ‰é”®äº‹ä»¶KEY_EVENTç»‘å®šå…³ç³»(ä¸€å®šè¦ä¸€ä¸€å¯¹åº”)
                  {TOUCH_KEY_ID_1, TOUCH_KEY_EVENT_ID_1_CLICK, TOUCH_KEY_EVENT_ID_1_DOUBLE, TOUCH_KEY_EVENT_ID_1_LONG, T
             -OUCH_KEY_EVENT_ID_1_HOLD, TOUCH_KEY_EVENT_ID_1_LOOSE}, //
                  {TOUCH_KEY_ID_2, TOUCH_KEY_EVENT_ID_2_CLICK, TOUCH_KEY_EVENT_ID_2_DOUBLE, TOUCH_KEY_EVENT_ID_2_LONG, T
             -OUCH_KEY_EVENT_ID_2_HOLD, TOUCH_KEY_EVENT_ID_2_LOOSE}, //
              };
              
              extern u8 touch_key_get_key_id(void);
              volatile struct key_driver_para touch_key_para = {
                  // ç¼–è¯‘å™¨ä¸æ”¯æŒæŒ‡å®šæˆå‘˜èµ‹å€¼çš„å†™æ³•ï¼Œä¼šæŠ¥é”™ï¼š
                  // .scan_times = 10,   // æ‰«æé¢‘ç‡ï¼Œå•ä½ï¼šms
                  // .last_key = NO_KEY, // ä¸Šä¸€æ¬¡å¾—åˆ°çš„æŒ‰é”®é”®å€¼ï¼Œåˆå§‹åŒ–ä¸ºæ— æ•ˆçš„é”®å€¼
                  // // .filter_value = NO_KEY, // æŒ‰é”®æ¶ˆæŠ–æœŸé—´å¾—åˆ°çš„é”®å€¼(åœ¨key_driver_scan()å‡½æ•°ä¸­ä½¿ç”¨
             -)ï¼Œåˆå§‹åŒ–ä¸º NO_KEY
                  // // .filter_cnt = 0, // æŒ‰é”®æ¶ˆæŠ–æœŸé—´çš„ç´¯åŠ å€¼(åœ¨key_driver_scan()å‡½æ•°ä¸­ä½¿ç”¨)ï¼Œåˆå§‹
             -åŒ–ä¸º0
                  // .filter_time = 3,       // æŒ‰é”®æ¶ˆæŠ–æ¬¡æ•°ï¼Œä¸æ‰«æé¢‘ç‡æœ‰å…³
                  // .long_time = 50,        // åˆ¤å®šæŒ‰é”®æ˜¯é•¿æŒ‰å¯¹åº”çš„æ•°é‡ï¼Œä¸æ‰«æé¢‘ç‡æœ‰å…³
                  // .hold_time = (75 + 15), // åˆ¤å®šæŒ‰é”®æ˜¯HOLDå¯¹åº”çš„æ•°é‡ï¼Œä¸æ‰«æé¢‘ç‡æœ‰å…³
                  // // .press_cnt = 0, // ä¸long_timeå’Œhold_timeå¯¹æ¯”, åˆ¤æ–­é•¿æŒ‰äº‹ä»¶å’ŒHOLDäº‹ä»¶
                  // // .click_cnt = 0,
                  // .click_delay_time = 20, // æŒ‰é”®æŠ¬èµ·åï¼Œç­‰å¾…è¿å‡»çš„æ•°é‡ï¼Œä¸æ‰«æé¢‘ç‡æœ‰å…³
C51 COMPILER V9.60.7.0   TOUCH_KEY                                                         12/12/2025 11:46:26 PAGE 2   

                  // // .notify_value = 0,
                  // .key_type = KEY_TYPE_AD, // æŒ‰é”®ç±»å‹ä¸ºadæŒ‰é”®
                  // .get_value = ad_key_get_key_id,
              
                  // .latest_key_val = AD_KEY_ID_NONE,
                  // .latest_key_event = KEY_EVENT_NONE,
              
                  TOUCH_KEY_SCAN_CIRCLE_TIMES,
                  0,
                  // NO_KEY,
                  0,
              
                  0,
                  0,
                  3,
              
                  TOUCH_KEY_LONG_PRESS_TIME_THRESHOLD_MS / TOUCH_KEY_SCAN_CIRCLE_TIMES,
                  (TOUCH_KEY_LONG_PRESS_TIME_THRESHOLD_MS + TOUCH_KEY_HOLD_PRESS_TIME_THRESHOLD_MS) / TOUCH_KEY_SCAN_CIR
             -CLE_TIMES,
                  0,
              
                  0,
                  0,
                  // 200 / TOUCH_KEY_SCAN_CIRCLE_TIMES,
                  0,
                  // NO_KEY,
                  0,
                  KEY_TYPE_TOUCH,
                  touch_key_get_key_id,
              
                  TOUCH_KEY_ID_NONE,
                  KEY_EVENT_NONE,
              };
              
              static u8 touch_key_get_key_id(void)
              {
                  unsigned long tk_key_val = 0;
                  u8 ret = NO_KEY;
              
                  // delay_ms(1); // å»¶æ—¶å¹¶ä¸èƒ½è§£å†³åˆšä¸Šç‚¹å°±æ£€æµ‹åˆ°é•¿æŒ‰çš„é—®é¢˜
              
                  // printf("touch key scan\n");
              
                  tk_key_val = __tk_key_flag;
              #if 1
                  if (TK_CH9_VALIB == __tk_key_flag)
                  {
                      ret = TOUCH_KEY_ID_1;
                      // return TOUCH_KEY_ID_1;
                  }
                  else if (TK_CH10_VALIB == __tk_key_flag)
                  {
                      ret = TOUCH_KEY_ID_2;
                      // return TOUCH_KEY_ID_2;
                  }
                  else
                  {
                      // return TOUCH_KEY_ID_NONE;
                      // return NO_KEY;
                  }
              #endif
              
C51 COMPILER V9.60.7.0   TOUCH_KEY                                                         12/12/2025 11:46:26 PAGE 3   

              #if 0
                  if (TK_CH10_VALIB == __tk_key_flag)
                  {
                      ret = TOUCH_KEY_ID_2;
                      // return TOUCH_KEY_ID_1;
                  }
                  else if (TK_CH9_VALIB == __tk_key_flag)
                  {
                      ret = TOUCH_KEY_ID_1;
                      // return TOUCH_KEY_ID_2;
                  }
                  else
                  {
                      // return TOUCH_KEY_ID_NONE;
                      // return NO_KEY;
                  }
              #endif
              
                  tk_key_val = 0;
              
                  // return __tk_key_flag;        // __tk_key_flag å•æ¬¡æŒ‰é”®æ ‡å¿—
                  return ret;
              }
              
              /**
               * @brief å°†æŒ‰é”®å€¼å’Œkey_driver_scanå¾—åˆ°çš„æŒ‰é”®äº‹ä»¶è½¬æ¢æˆè§¦æ‘¸æŒ‰é”®çš„äº‹ä»¶
               *
               * @param key_val è§¦æ‘¸æŒ‰é”®é”®å€¼
               * @param key_event åœ¨key_driver_scanå¾—åˆ°çš„æŒ‰é”®äº‹ä»¶ KEY_EVENT
               * @return u8 åœ¨touch_key_event_tableä¸­æ‰¾åˆ°çš„å¯¹åº”çš„æŒ‰é”®äº‹ä»¶ï¼Œå¦‚æœæ²¡æœ‰åˆ™è¿”å› TOUCH_KEY_
             -EVENT_NONE
               */
              static u8 __touch_key_get_event(const u8 key_val, const u8 key_event)
              {
                  volatile u8 ret_key_event = TOUCH_KEY_EVENT_NONE;
                  u8 i = 0;
                  for (; i < ARRAY_SIZE(touch_key_event_table); i++)
                  {
                      // å¦‚æœå¾€ KEY_EVENT æšä¸¾ä¸­æ·»åŠ äº†æ–°çš„æŒ‰é”®äº‹ä»¶ï¼Œè¿™é‡ŒæŸ¥è¡¨çš„æ–¹æ³•å°±ä¼šå¤±æ•ˆï¼Œ
             -éœ€è¦æ‰‹åŠ¨ä¿®æ”¹
                      if (key_val == touch_key_event_table[i][0])
                      {
                          ret_key_event = touch_key_event_table[i][key_event];
                          break;
                      }
                  }
              
                  return ret_key_event;
              }
              
              void touch_key_handle(void)
              {
                  u8 touch_key_event = TOUCH_KEY_EVENT_NONE;
              
                  if (touch_key_para.latest_key_val == TOUCH_KEY_ID_NONE)
                  {
                      return;
                  }
              
                  touch_key_event = __touch_key_get_event(touch_key_para.latest_key_val, touch_key_para.latest_key_event
             -);
                  touch_key_para.latest_key_val = TOUCH_KEY_ID_NONE;
C51 COMPILER V9.60.7.0   TOUCH_KEY                                                         12/12/2025 11:46:26 PAGE 4   

                  touch_key_para.latest_key_event = KEY_EVENT_NONE;
              
                  switch (touch_key_event)
                  {
                  case TOUCH_KEY_EVENT_ID_1_CLICK:
                      // printf("touch key 1 click\n");
                      send_data(SEND_TOUCH_KEY_STATUS, (u32)TOUCH_KEY_CLICK_MSG << 16 | TOUCH_KEY_SEND_INFO_1); // DEBUG
             - æµ‹è¯•æ—¶å±è”½ï¼Œåº”è¯¥æ¢å¤
              
                      // DEBUG
                      // if (fuel_adc_val < 4095 - 100)
                      // {
                      //     fuel_adc_val += 100;
                      // }
              
                      break;
              
                  case TOUCH_KEY_EVENT_ID_1_DOUBLE:
                      // printf("touch key 1 double\n");
                      break;
              
                  case TOUCH_KEY_EVENT_ID_1_LONG:
                      // printf("touch key 1 long\n");
                      send_data(SEND_TOUCH_KEY_STATUS, (u32)TOUCH_KEY_LONG_MSG << 16 | TOUCH_KEY_SEND_INFO_1);
                      break;
              
                  case TOUCH_KEY_EVENT_ID_1_HOLD:
                      // printf("touch key 1 hold\n");
                      send_data(SEND_TOUCH_KEY_STATUS, (u32)TOUCH_KEY_HOLD_MSG << 16 | TOUCH_KEY_SEND_INFO_1);
                      break;
              
                  case TOUCH_KEY_EVENT_ID_1_LOOSE:
                      // printf("touch key 1 loose\n");
                      send_data(SEND_TOUCH_KEY_STATUS, (u32)TOUCH_KEY_LOOSE_MSG << 16 | TOUCH_KEY_SEND_INFO_1);
                      break;
                  case TOUCH_KEY_EVENT_ID_2_CLICK:
                      // printf("touch key 2 click\n");
                      send_data(SEND_TOUCH_KEY_STATUS, (u32)TOUCH_KEY_CLICK_MSG << 16 | TOUCH_KEY_SEND_INFO_2); // DEBUG
             - æµ‹è¯•æ—¶å±è”½ï¼Œåº”è¯¥æ¢å¤
              
                      // DEBUG
                      // if (fuel_adc_val > 100)
                      // {
                      //     fuel_adc_val -= 100;
                      // }
                      break;
              
                  case TOUCH_KEY_EVENT_ID_2_DOUBLE:
                      // printf("touch key 2 double\n");
                      break;
              
                  case TOUCH_KEY_EVENT_ID_2_LONG:
                      // printf("touch key 2 long\n");
                      send_data(SEND_TOUCH_KEY_STATUS, (u32)TOUCH_KEY_LONG_MSG << 16 | TOUCH_KEY_SEND_INFO_2);
                      break;
              
                  case TOUCH_KEY_EVENT_ID_2_HOLD:
                      // printf("touch key 2 hold\n");
                      send_data(SEND_TOUCH_KEY_STATUS, (u32)TOUCH_KEY_HOLD_MSG << 16 | TOUCH_KEY_SEND_INFO_2);
                      break;
              
                  case TOUCH_KEY_EVENT_ID_2_LOOSE:
C51 COMPILER V9.60.7.0   TOUCH_KEY                                                         12/12/2025 11:46:26 PAGE 5   

                      // printf("touch key 2 loose\n");
                      send_data(SEND_TOUCH_KEY_STATUS, (u32)TOUCH_KEY_LOOSE_MSG << 16 | TOUCH_KEY_SEND_INFO_2);
                      break;
              
                  default:
                      break;
                  }
              }
              
              #endif // (TOUCH_KEY_ENABLE)


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   ----    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
