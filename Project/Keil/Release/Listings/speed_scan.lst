C51 COMPILER V9.60.7.0   SPEED_SCAN                                                        12/05/2025 17:29:00 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE SPEED_SCAN
OBJECT MODULE PLACED IN .\Release\Objects\speed_scan.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\User\speed_scan.c LARGE OPTIMIZE(9,SIZE) BROWSE ORDER INTVECTOR(0X
                    -000C) INCDIR(..\..\Libraries\Include;..\..\User;..\..\User\lib;..\..\Hardware) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(.\Re
                    -lease\Listings\speed_scan.lst) OBJECT(.\Release\Objects\speed_scan.obj)

line level    source

   1          #include "speed_scan.h"
   2          
   3          #if SPEED_SCAN_ENABLE
   4          
   5          // æ—¶é€Ÿæ‰«æçš„é…ç½®
   6          void speed_scan_config(void)
   7          {
   8   1      #if 1 // ä½¿ç”¨å®šæ—¶å™¨æ‰«æIOç”µå¹³å˜åŒ–æ¥è®¡ç®—è„‰å†²
   9   1      
  10   1          P1_MD1 &= ~GPIO_P15_MODE_SEL(0x3); // è¾“å…¥æ¨¡å¼
  11   1          P1_PU |= GPIO_P15_PULL_UP(0x1);    // é…ç½®ä¸ºä¸Šæ‹‰
  12   1      
  13   1      #endif // ä½¿ç”¨å®šæ—¶å™¨æ‰«æIOç”µå¹³å˜åŒ–æ¥è®¡ç®—è„‰å†²
  14   1      }
  15           
  16          
  17          volatile bit flag_is_speed_scan_over_time = 0; // é€Ÿåº¦æ£€æµ‹æ˜¯å¦ä¸€ç›´æ²¡æœ‰è„‰å†²åˆ°æ¥ï¼Œå¯¼è‡´è¶…æ—
             -¶
  18          volatile u32 speed_pulse_cnt = 0;              // è®°å½•è„‰å†²ä¸ªæ•°ï¼Œåœ¨å®šæ—¶å™¨ä¸­æ–­ç´¯åŠ 
  19          volatile u32 speed_scan_time_ms = 0;           // è®°å½•æ‰«ææ—¶é—´
  20          static volatile u32 cur_speed_scan_time = 0;
  21          static volatile u32 cur_speed_scan_pulse = 0;
  22          
  23          void update_speed_scan_data(void) // æ›´æ–°æ£€æµ‹æ—¶é€Ÿçš„æ•°æ®
  24          {
  25   1          cur_speed_scan_time += speed_scan_time_ms;
  26   1          speed_scan_time_ms = 0;
  27   1          cur_speed_scan_pulse += speed_pulse_cnt;
  28   1          speed_pulse_cnt = 0;
  29   1      }
  30          
  31          void speed_scan(void)
  32          {
  33   1          volatile u32 cur_speed = 0;
  34   1          u32 tmp = 0;
  35   1      
  36   1          if (cur_speed_scan_time >= SPEED_SCAN_UPDATE_TIME || flag_is_speed_scan_over_time)
  37   1          {
  38   2              /*
  39   2                  é‡‡é›†åˆ°çš„è„‰å†²ä¸ªæ•° / ä¸€åœˆå¯¹åº”çš„è„‰å†²ä¸ªæ•° * è½¦è½®ä¸€åœˆå¯¹åº”èµ°è¿‡çš„è·ç¦»ï¼ˆå
             -•ä½ï¼šmmï¼‰ï¼Œ
  40   2                  è®¡ç®—å¾—åˆ° é‡‡é›†çš„è„‰å†²ä¸ªæ•°å¯¹åº”èµ°è¿‡çš„è·ç¦»ï¼ˆå•ä½ï¼šmmï¼‰
  41   2              */
  42   2              // u32 tmp = (cur_speed_scan_pulse * SPEED_SCAN_MM_PER_TURN / SPEED_SCAN_PULSE_PER_TURN);
  43   2              tmp = ((cur_speed_scan_pulse * SPEED_SCAN_MM_PER_TURN) / SPEED_SCAN_PULSE_PER_TURN);
  44   2              // printf("cur_speed_scan_pulse %lu\n", cur_speed_scan_pulse);
  45   2      
  46   2              if (flag_is_speed_scan_over_time) // è¶…æ—¶ï¼Œé‡‡é›†åˆ°çš„è„‰å†²ä¸ªæ•°å¯¹åº”ä¸€ç›´æ˜¯0km/hï¼Œè®¤ä¸
             -ºæ—¶é€Ÿæ˜¯0
  47   2              {
  48   3                  cur_speed = 0;
  49   3              }
  50   2              else // æœªè¶…æ—¶ï¼Œè®¡ç®—é‡‡é›†åˆ°çš„è„‰å†²ä¸ªæ•°å¯¹åº”èµ°è¿‡çš„è·ç¦»ï¼Œå†è½¬æ¢æˆä»¥km/hçš„å
C51 COMPILER V9.60.7.0   SPEED_SCAN                                                        12/05/2025 17:29:00 PAGE 2   

             -•ä½
  51   2              {
  52   3                  /*
  53   3                      é‡‡é›†çš„è„‰å†²ä¸ªæ•°å¯¹åº”èµ°è¿‡çš„è·ç¦»ï¼ˆå•ä½ï¼šmmï¼‰/ é‡‡é›†æ‰€ç”¨çš„æ—¶é—´ï¼ˆå•ä½
             -ï¼šmsï¼‰ == é€Ÿåº¦ï¼ˆå•ä½ï¼šmm/msï¼‰
  54   3                      1mm/ms == 1m/s
  55   3                      å› ä¸º 1mm/ms * 1000 == 1m/ms
  56   3                           1m/ms  / 1000 == 1m/s
  57   3                           å…ˆä¹˜ä»¥1000å†é™¤ä»¥1000ï¼Œé‚£ä¹ˆè¿™ä¸ªæ“ä½œå°±å¯ä»¥åŽ»æŽ‰ï¼Œç›´æŽ¥åŒ–ç®€ä¸º 1mm/
             -ms == 1m/s
  58   3      
  59   3                      1m/s == 3.6km/hï¼Œé‚£ä¹ˆæ ¹æ®å¾—åˆ°çš„ ä»¥ m/s ä¸ºå•ä½çš„é€Ÿåº¦ï¼Œå…ˆä¹˜ä»¥36å†é™¤ä»¥1
             -0ï¼Œå¾—åˆ°ä»¥km/hä¸ºå•ä½çš„é€Ÿåº¦å€¼
  60   3      
  61   3                      cur_speed == é‡‡é›†çš„è„‰å†²ä¸ªæ•°å¯¹åº”èµ°è¿‡çš„è·ç¦»ï¼ˆå•ä½ï¼šmmï¼‰/ é‡‡é›†æ‰€ç”¨çš„æ
             -—¶é—´ï¼ˆå•ä½ï¼šmsï¼‰* 3.6
  62   3                      æ¢æˆå•ç‰‡æœºå¯ä»¥è®¡ç®—çš„æ ¼å¼ï¼š
  63   3                      cur_speed == é‡‡é›†çš„è„‰å†²ä¸ªæ•°å¯¹åº”èµ°è¿‡çš„è·ç¦»ï¼ˆå•ä½ï¼šmmï¼‰ * 36 / 10 / é‡‡é›
             -†æ‰€ç”¨çš„æ—¶é—´ï¼ˆå•ä½ï¼šmsï¼‰
  64   3                  */
  65   3                  cur_speed = tmp * 36 / 10 / cur_speed_scan_time;
  66   3              }
  67   2      
  68   2              // é˜²æ­¢æ—¶é€Ÿä¸º0æ—¶ï¼ˆæœ‰å¯èƒ½æ˜¯æŽ¨è½¦ï¼Œè®°å½•ä¸åˆ°é€Ÿåº¦ï¼‰ï¼Œè®°å½•ä¸åˆ°é‡Œç¨‹
  69   2              distance += tmp;
  70   2      
  71   2              // printf("cur distace 2 %lu\n", distance);
  72   2              // printf("cur distace %lu\n", distance);
  73   2              // printf("cur speed %lu km/h\n", cur_speed);
  74   2      
  75   2              cur_speed_scan_pulse = 0;
  76   2              cur_speed_scan_time = 0;
  77   2              flag_is_speed_scan_over_time = 0;
  78   2      
  79   2              fun_info.speed = cur_speed;
  80   2              // é™åˆ¶è¦å‘é€çš„æ—¶é€Ÿ:
  81   2              // if (fun_info.speed > 999)
  82   2              // {
  83   2              //     fun_info.speed = 999;
  84   2              // }
  85   2      
  86   2              flag_get_speed = 1; // è¡¨ç¤ºé€Ÿåº¦æœ‰æ•°æ®æ›´æ–°
  87   2          } // if (cur_speed_scan_time >= 500 || flag_is_speed_scan_over_time)
  88   1      }
  89          
  90          #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    263    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     16       8
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
