C51 COMPILER V9.60.7.0   ENGINE_SPEED_SCAN                                                 12/05/2025 17:29:00 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE ENGINE_SPEED_SCAN
OBJECT MODULE PLACED IN .\Release\Objects\engine_speed_scan.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\User\engine_speed_scan.c LARGE OPTIMIZE(9,SIZE) BROWSE ORDER INTVE
                    -CTOR(0X000C) INCDIR(..\..\Libraries\Include;..\..\User;..\..\User\lib;..\..\Hardware) INTERVAL(3) DEBUG OBJECTEXTEND PRI
                    -NT(.\Release\Listings\engine_speed_scan.lst) OBJECT(.\Release\Objects\engine_speed_scan.obj)

line level    source

   1          #include "engine_speed_scan.h"
   2          
   3          #if ENGINE_SPEED_SCAN_ENABLE
   4          
   5          // å‘åŠ¨æœºè½¬é€Ÿçš„ç›¸å…³é…ç½®
   6          void engine_speed_scan_config(void)
   7          {
   8   1          // ä½¿ç”¨å®šæ—¶å™¨æ‰«æIOç”µå¹³çš„æ–¹å¼
   9   1      
  10   1          P0_MD0 &= ~GPIO_P02_MODE_SEL(0x3); // è¾“å…¥æ¨¡å¼
  11   1          P0_PU |= GPIO_P02_PULL_UP(0x01);   // ä¸Šæ‹‰
  12   1      }
  13          
  14          volatile u32 engine_speed_scan_cnt; // æ£€æµ‹åˆ°çš„è„‰å†²ä¸ªæ•°ï¼Œåœ¨å®šæ—¶å™¨ä¸­æ–­ç´¯åŠ 
  15          volatile u16 engine_speed_scan_ms;  // åœ¨å®šæ—¶å™¨ä¸­æ–­ç´¯åŠ 
  16          
  17          static volatile u32 cur_engine_speed_scan_cnt;
  18          static volatile u32 cur_engine_speed_scan_ms;
  19          
  20          volatile bit flag_is_engine_speed_scan_over_time; // æ ‡å¿—ä½ï¼Œæ£€æµ‹æ˜¯å¦è¶…æ—¶
  21          
  22          void update_engine_speed_scan_data(void) // æ›´æ–°æ£€æµ‹å‘åŠ¨æœºè½¬é€Ÿçš„æ•°æ®
  23          {
  24   1          cur_engine_speed_scan_cnt += engine_speed_scan_cnt;
  25   1          engine_speed_scan_cnt = 0;
  26   1          cur_engine_speed_scan_ms += engine_speed_scan_ms;
  27   1          engine_speed_scan_ms = 0;
  28   1      }
  29          
  30          // å‘åŠ¨æœºè½¬é€Ÿæ‰«æ
  31          void engine_speed_scan(void)
  32          {
  33   1      #define CONVER_ONE_MINUTE_TO_MS (60000UL) // å°†1minè½¬æ¢æˆä»¥msä¸ºå•ä½çš„æ•°æ®
  34   1          volatile u32 rpm;                     // ç”±ä¸‹é¢çš„è¯­å¥èµ‹å€¼ï¼Œè¿™é‡Œä¸ºäº†èŠ‚çœç¨‹åºç©ºé—´ï¼Œæ
             -²¡æœ‰èµ‹åˆå§‹å€¼
  35   1      
  36   1          if (cur_engine_speed_scan_ms >= ENGINE_SPEED_SCAN_UPDATE_TIME || flag_is_engine_speed_scan_over_time)
  37   1          // if (cur_engine_speed_scan_ms >= ENGINE_SPEED_SCAN_UPDATE_TIME )
  38   1          {
  39   2              // printf("cur_engine_speed_scan_ms:%lu\n", cur_engine_speed_scan_ms);
  40   2              if (flag_is_engine_speed_scan_over_time)
  41   2              {
  42   3                  rpm = 0;
  43   3              }
  44   2              else
  45   2              {
  46   3                  /*
  47   3                      (1min / 1minè½¬è¿‡çš„åœˆæ•°) == (æ‰«ææ—¶é—´ / æ‰«ææ—¶é—´å†…çš„è½¬è¿‡çš„åœˆæ•°)
  48   3                      1minè½¬è¿‡çš„åœˆæ•° == 1min * æ‰«ææ—¶é—´å†…è½¬è¿‡çš„åœˆæ•° / æ‰«ææ—¶é—´
  49   3                      1minè½¬è¿‡çš„åœˆæ•° == 1min * (æ‰«ææ—¶é—´å†…é‡‡é›†åˆ°çš„è„‰å†²ä¸ªæ•° / å‘åŠ¨æœºè½¬è¿‡ä¸
             -€åœˆå¯¹åº”çš„è„‰å†²ä¸ªæ•°) / æ‰«ææ—¶é—´
  50   3                      è½¬æ¢æˆå•ç‰‡æœºèƒ½è®¡ç®—çš„å½¢å¼ï¼š
  51   3                      1minè½¬è¿‡çš„åœˆæ•° == æ‰«ææ—¶é—´å†…é‡‡é›†åˆ°çš„è„‰å†²ä¸ªæ•° * 1min / å‘åŠ¨æœºè½¬è¿‡ä¸€
C51 COMPILER V9.60.7.0   ENGINE_SPEED_SCAN                                                 12/05/2025 17:29:00 PAGE 2   

             -åœˆå¯¹åº”çš„è„‰å†²ä¸ªæ•° / æ‰«ææ—¶é—´
  52   3                      1minè½¬è¿‡çš„åœˆæ•° == æ‰«ææ—¶é—´å†…é‡‡é›†åˆ°çš„è„‰å†²ä¸ªæ•° * 1min / æ‰«ææ—¶é—´ / å‘
             -åŠ¨æœºè½¬è¿‡ä¸€åœˆå¯¹åº”çš„è„‰å†²ä¸ªæ•°
  53   3                  */
  54   3                  // rpm = (u32)cur_engine_speed_scan_cnt * ((u32)CONVER_ONE_MINUTE_TO_MS / ENGINE_SPEED_SCAN_PU
             -LSE_PER_TURN) / cur_engine_speed_scan_ms;
  55   3      
  56   3                  /*
  57   3                      æ‰«ææ—¶é—´å†…è½¬è¿‡çš„åœˆæ•° == ä¸€ä¸ªè„‰å†²å¯¹åº”è½¬è¿‡çš„åœˆæ•° *ã€€æ‰«ææ—¶é—´å†…é‡‡
             -é›†åˆ°çš„è„‰å†²ä¸ªæ•°
  58   3                      1minè½¬è¿‡çš„åœˆæ•°ã€€== æ‰«ææ—¶é—´å†…è½¬è¿‡çš„åœˆæ•° / æ‰«ææ—¶é—´ * 1min
  59   3                  */
  60   3                  rpm = (u32)cur_engine_speed_scan_cnt * ENGINE_SPEED_SCAN_A_PULSE_PER_TURNS * CONVER_ONE_MINUTE
             -_TO_MS / cur_engine_speed_scan_ms;
  61   3              }
  62   2      
  63   2              // printf("cur engine speed pulse cnt:%lu\n",cur_engine_speed_scan_cnt);
  64   2      
  65   2              cur_engine_speed_scan_cnt = 0;
  66   2              cur_engine_speed_scan_ms = 0;
  67   2              flag_is_engine_speed_scan_over_time = 0;
  68   2      
  69   2              // é™åˆ¶å¾…å‘é€çš„å‘åŠ¨æœºè½¬é€Ÿ
  70   2              if (rpm >= 65535)
  71   2              {
  72   3                  rpm = 65535;
  73   3              }
  74   2      
  75   2      #if 1
  76   2              /*
  77   2                  æ‰«æå®Œå°±å‘é€çš„ç¨‹åºï¼Œåœ¨æ˜¾ç¤ºéƒ¨åˆ†ä¼šæœ‰å¡é¡¿ï¼Œ
  78   2                  æ˜¾ç¤ºåšä¸äº†åŠ¨ç”»ï¼Œåªèƒ½å•ç‰‡æœºæ¥è°ƒèŠ‚
  79   2              */
  80   2      
  81   2              // printf("cur rpm %lu\n", rpm);
  82   2      
  83   2              fun_info.engine_speeed = rpm; // å‘å…¨å±€å˜é‡å­˜æ”¾å‘åŠ¨æœºè½¬é€Ÿ
  84   2              flag_get_engine_speed = 1;    // å‘é€å‘åŠ¨æœºè½¬é€Ÿ
  85   2      #endif
  86   2      
  87   2              // engine_speed_buff_update(rpm);
  88   2          }
  89   1      }
  90          
  91          #if 0
              void engine_speed_buff_update(u32 engine_speed)
              {
                  static u32 last_engine_speed;       // å­˜æ”¾ä¸Šä¸€æ¬¡é‡‡é›†åˆ°çš„å‘åŠ¨æœºè½¬é€Ÿ
                  u32 engine_speed_difference = 0;    // å­˜æ”¾ å‘åŠ¨æœºè½¬é€Ÿ çš„å·®å€¼
                  bit dir_of_engine_speed_change = 0; // å‘åŠ¨æœºè½¬é€Ÿå˜åŒ–çš„æ–¹å‘ï¼Œ0--å˜å°ï¼Œ1--å˜å¤§
                  u8 i;                               // å¾ªç¯è®¡æ•°å€¼ï¼ˆç”±ä¸‹é¢çš„è¯­å¥èµ‹å€¼ï¼Œè¿™é‡Œä¸ºäº†èŠ‚çœ
             -ç¨‹åºç©ºé—´ï¼Œæ²¡æœ‰ç»™åˆå§‹å€¼ï¼‰
              
                  if (engine_speed > last_engine_speed)
                  {
                      // å¦‚æœå½“å‰çš„å‘åŠ¨æœºè½¬é€Ÿ å¤§äº ä¸Šä¸€æ¬¡é‡‡é›†åˆ°çš„å‘åŠ¨æœºè½¬é€Ÿ
                      engine_speed_difference = engine_speed - last_engine_speed;
                      dir_of_engine_speed_change = 1; // è¡¨ç¤ºå‘åŠ¨æœºè½¬é€Ÿå˜å¤§
                  }
                  else if (engine_speed < last_engine_speed)
                  {
                      // å¦‚æœå½“å‰çš„å‘åŠ¨æœºè½¬é€Ÿ å°äº ä¸Šä¸€æ¬¡é‡‡é›†åˆ°çš„å‘åŠ¨æœºè½¬é€Ÿ
C51 COMPILER V9.60.7.0   ENGINE_SPEED_SCAN                                                 12/05/2025 17:29:00 PAGE 3   

                      engine_speed_difference = last_engine_speed - engine_speed;
                      dir_of_engine_speed_change = 0; // è¡¨ç¤ºå‘åŠ¨æœºè½¬é€Ÿå˜å°
                  }
                  else
                  {
                      for (i = 0; i < ENGINE_SPEED_SCAN_BUFF_SIZE; i++)
                      {
                          engine_speed_buff[i] = engine_speed;
                      }
              
                      // // æ²¡æœ‰å·®å€¼ï¼Œç›´æ¥æ›´æ–°ï¼ˆä¿®å¤æ²¡æœ‰å·®å€¼ä¸”æ•°å€¼ä¸º0æ—¶ï¼Œæ²¡æœ‰å‘é€æ•°æ®çš„é—®é
             -¢˜ï¼‰
                      // fun_info.engine_speeed = engine_speed;
                      // flag_get_engine_speed = 1;
              
                      cur_send_engine_speed_buff_index = 0; // æ¸¸æ ‡å¤ä½
                      return;
                  }
              
                  if (dir_of_engine_speed_change)
                  {
                      // å¦‚æœå‘åŠ¨æœºè½¬é€Ÿåœ¨å˜å¤§ï¼Œæ•°ç»„ä» [0] ~ [ENGINE_SPEED_SCAN_BUFF_SIZE - 1] æ•°å€¼è¶Šæ¥
             -è¶Šå¤§
                      for (i = 0; i < ENGINE_SPEED_SCAN_BUFF_SIZE; i++)
                      {
                          engine_speed_buff[i] = engine_speed_difference * (i + 1) / ENGINE_SPEED_SCAN_BUFF_SIZE + last_
             -engine_speed;
                      }
                  }
                  else
                  {
                      // å¦‚æœå‘åŠ¨æœºè½¬é€Ÿåœ¨å˜å°ï¼Œæ•°ç»„ä» [0] ~ [ENGINE_SPEED_SCAN_BUFF_SIZE - 1] æ•°å€¼è¶Šæ¥
             -è¶Šå°
                      for (i = 0; i < ENGINE_SPEED_SCAN_BUFF_SIZE; i++)
                      {
                          // è¿™ä¸€å¥ä¼šå¯¼è‡´æœ€åä¸èƒ½æ˜¾ç¤º æ•°å€¼ä¸º0 ï¼š
                          // engine_speed_buff[ENGINE_SPEED_SCAN_BUFF_SIZE - 1 - i] = last_engine_speed - (u32)engine_sp
             -eed_difference * (ENGINE_SPEED_SCAN_BUFF_SIZE - i - 1) / ENGINE_SPEED_SCAN_BUFF_SIZE;
              
                          engine_speed_buff[ENGINE_SPEED_SCAN_BUFF_SIZE - 1 - i] = last_engine_speed - (u32)engine_speed
             -_difference * (ENGINE_SPEED_SCAN_BUFF_SIZE - i - 1) / ENGINE_SPEED_SCAN_BUFF_SIZE;
                      }
                  }
              
                  last_engine_speed = engine_speed;
                  cur_send_engine_speed_buff_index = 0; // æ¸¸æ ‡å¤ä½
              }
              
              void engine_speed_send_data(void)
              {
                  if (flag_is_send_engine_speed_time_come) // å¦‚æœå‘é€ å‘åŠ¨æœºè½¬é€Ÿçš„æ—¶é—´åˆ°æ¥
                  {
                      flag_is_send_engine_speed_time_come = 0;
              
                      if (cur_send_engine_speed_buff_index >= ENGINE_SPEED_SCAN_BUFF_SIZE)
                      {
                          // é˜²æ­¢è¶Šç•Œ
                          return;
                      }
              
                      fun_info.engine_speeed = engine_speed_buff[cur_send_engine_speed_buff_index];
                      cur_send_engine_speed_buff_index++;
C51 COMPILER V9.60.7.0   ENGINE_SPEED_SCAN                                                 12/05/2025 17:29:00 PAGE 4   

              
                      // printf("fun_info.engine_speed = %lu\n", fun_info.engine_speeed);
                      flag_get_engine_speed = 1;
                  }
              }
              #endif
 170          
 171          #endif // #if ENGINE_SPEED_SCAN_ENABLE


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    209    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     14       4
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
